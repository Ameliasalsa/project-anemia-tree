# -*- coding: utf-8 -*-
"""Copy of Untitled25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jkXiI9fM8fk2u5q2hM9bVT4RCodSPErH
"""

# STEP 1: Setup Dataset
import os

# Buat file CSV jika belum ada
if not os.path.exists("data_anemia.csv"):
    with open("data_anemia.csv", "w") as f:
        f.write("""durasi,konsumsi,lemas,berat_badan_turun,usia,riwayat_keluarga,risiko
7,0,2,2,25,1,tinggi
4,2,0,0,19,0,rendah
6,1,1,1,30,1,sedang
8,0,2,2,32,1,tinggi
5,1,1,1,24,0,sedang
3,2,0,0,18,0,rendah
""")
    print("‚úÖ File 'data_anemia.csv' berhasil dibuat.")
else:
    print("üìÅ File sudah ada.")

# STEP 2: Decision Tree Functions
import csv
from random import shuffle

def load_data_from_csv(filepath):
    data = []
    with open(filepath, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            data.append({
                "durasi": int(row["durasi"]),
                "konsumsi": int(row["konsumsi"]),
                "lemas": int(row["lemas"]),
                "berat_badan_turun": int(row["berat_badan_turun"]),
                "usia": int(row["usia"]),
                "riwayat_keluarga": int(row["riwayat_keluarga"]),
                "risiko": row["risiko"].strip().lower()
            })
    return data

def gini(data):
    total = len(data)
    if total == 0:
        return 0
    counts = {}
    for row in data:
        label = row["risiko"]
        counts[label] = counts.get(label, 0) + 1
    impurity = 1
    for label in counts:
        prob = counts[label] / total
        impurity -= prob**2
    return impurity

def split(data, feature, value):
    left = [row for row in data if row[feature] <= value]
    right = [row for row in data if row[feature] > value]
    return left, right

def best_split(data):
    best_gini = 1
    best_feature = None
    best_value = None
    best_sets = None
    for feature in ["durasi", "konsumsi", "lemas", "berat_badan_turun", "usia", "riwayat_keluarga"]:
        values = set([row[feature] for row in data])
        for val in values:
            left, right = split(data, feature, val)
            g = (len(left) / len(data)) * gini(left) + (len(right) / len(data)) * gini(right)
            if g < best_gini:
                best_gini = g
                best_feature = feature
                best_value = val
                best_sets = (left, right)
    return best_feature, best_value, best_sets

def build_tree(data, depth=0):
    labels = set(row["risiko"] for row in data)
    if len(labels) == 1:
        return labels.pop()
    if depth >= 4 or len(data) < 2:
        counts = {}
        for row in data:
            counts[row["risiko"]] = counts.get(row["risiko"], 0) + 1
        return max(counts, key=counts.get)

    feature, value, sets = best_split(data)
    if not feature:
        return "tidak_dapat_split"

    left_branch = build_tree(sets[0], depth + 1)
    right_branch = build_tree(sets[1], depth + 1)

    return {"feature": feature, "value": value, "left": left_branch, "right": right_branch}

def predict(tree, sample):
    if isinstance(tree, str):
        return tree
    branch = tree["left"] if sample[tree["feature"]] <= tree["value"] else tree["right"]
    return predict(branch, sample)

def evaluate(data, test_ratio=0.3):
    shuffle(data)
    split_point = int(len(data) * (1 - test_ratio))
    train_data = data[:split_point]
    test_data = data[split_point:]
    tree = build_tree(train_data)
    correct = 0
    for row in test_data:
        if predict(tree, row) == row["risiko"]:
            correct += 1
    print(f"üìä Akurasi pada data uji: {correct/len(test_data):.2f}")

def print_tree(tree, spacing=""):
    if isinstance(tree, str):
        print(spacing + "=>", tree.upper())
        return
    print(spacing + f"[{tree['feature']} <= {tree['value']}]")
    print(spacing + '--> True:')
    print_tree(tree['left'], spacing + "  ")
    print(spacing + '--> False:')
    print_tree(tree['right'], spacing + "  ")

# STEP 3: Bangun & Evaluasi Model
data = load_data_from_csv("data_anemia.csv")
tree = build_tree(data)

print("=== STRUKTUR POHON KEPUTUSAN ===")
print_tree(tree)

evaluate(data)

# STEP 4: Prediksi Manual
import ipywidgets as widgets
from IPython.display import display

durasi = widgets.IntSlider(value=5, min=1, max=10, description='Durasi')
konsumsi = widgets.Dropdown(options=['sering', 'kadang', 'jarang'], description='Konsumsi')
lemas = widgets.Dropdown(options=['sering', 'kadang', 'tidak'], description='Lemas')
turun_bb = widgets.Dropdown(options=['sering', 'kadang', 'tidak'], description='Turun BB')
usia = widgets.IntSlider(value=25, min=10, max=60, description='Usia')
riwayat = widgets.Dropdown(options=['ya', 'tidak'], description='Riwayat')

print("üì• Silakan isi data berikut:")
display(durasi, konsumsi, lemas, turun_bb, usia, riwayat)

# STEP 5: Jalankan prediksi berdasarkan input form

# Pemetaan nilai dropdown ke angka
map3 = {"tidak": 0, "jarang": 0, "kadang": 1, "sering": 2}
map2 = {"tidak": 0, "ya": 1}

# Ambil nilai dari widget
sample = {
    "durasi": durasi.value,
    "konsumsi": map3.get(konsumsi.value),
    "lemas": map3.get(lemas.value),
    "berat_badan_turun": map3.get(turun_bb.value),
    "usia": usia.value,
    "riwayat_keluarga": map2.get(riwayat.value)
}

# Prediksi hasilnya
hasil = predict(tree, sample)
print(f"\nü©∫ Risiko anemia kamu diprediksi: {hasil.upper()}")