# -*- coding: utf-8 -*-
"""Copy of Untitled25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jkXiI9fM8fk2u5q2hM9bVT4RCodSPErH
"""

import os

if os.path.exists("data_anemia.csv"):
    os.remove("data_anemia.csv")
    print("📂 File lama dihapus.")

# Lalu buat ulang file-nya
with open("data_anemia.csv", "w") as f:
    f.write(
        "durasi_mens,konsumsi,lemas,berat_badan_turun,usia,riwayat_keluarga,sleep_kurang,risiko\n"
        "15,0,2,2,25,1,2,tinggi\n"
        "6,2,0,0,19,0,0,rendah\n"
        "10,1,1,1,30,1,1,sedang\n"
        "17,0,2,2,32,1,2,tinggi\n"
        "8,1,1,1,24,0,1,sedang\n"
        "5,2,0,0,18,0,0,rendah\n"
    )
print("✅ File 'data_anemia.csv' berhasil diperbarui.")

# STEP 2: Decision Tree Functions
import csv
from random import shuffle

def load_data_from_csv(filepath):
    data = []
    with open(filepath, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            data.append({
                "durasi": int(row["durasi"]),
                "konsumsi": int(row["konsumsi"]),
                "lemas": int(row["lemas"]),
                "berat_badan_turun": int(row["berat_badan_turun"]),
                "usia": int(row["usia"]),
                "riwayat_keluarga": int(row["riwayat_keluarga"]),
                "risiko": row["risiko"].strip().lower()
            })
    return data

def gini(data):
    total = len(data)
    if total == 0:
        return 0
    counts = {}
    for row in data:
        label = row["risiko"]
        counts[label] = counts.get(label, 0) + 1
    impurity = 1
    for label in counts:
        prob = counts[label] / total
        impurity -= prob**2
    return impurity

def split(data, feature, value):
    left = [row for row in data if row[feature] <= value]
    right = [row for row in data if row[feature] > value]
    return left, right

def best_split(data):
    best_gini = 1
    best_feature = None
    best_value = None
    best_sets = None
    for feature in ["durasi", "konsumsi", "lemas", "berat_badan_turun", "usia", "riwayat_keluarga"]:
        values = set([row[feature] for row in data])
        for val in values:
            left, right = split(data, feature, val)
            g = (len(left) / len(data)) * gini(left) + (len(right) / len(data)) * gini(right)
            if g < best_gini:
                best_gini = g
                best_feature = feature
                best_value = val
                best_sets = (left, right)
    return best_feature, best_value, best_sets

def build_tree(data, depth=0):
    labels = set(row["risiko"] for row in data)
    if len(labels) == 1:
        return labels.pop()
    if depth >= 4 or len(data) < 2:
        counts = {}
        for row in data:
            counts[row["risiko"]] = counts.get(row["risiko"], 0) + 1
        return max(counts, key=counts.get)

    feature, value, sets = best_split(data)
    if not feature:
        return "tidak_dapat_split"

    left_branch = build_tree(sets[0], depth + 1)
    right_branch = build_tree(sets[1], depth + 1)

    return {"feature": feature, "value": value, "left": left_branch, "right": right_branch}

def predict(tree, sample):
    if isinstance(tree, str):
        return tree
    branch = tree["left"] if sample[tree["feature"]] <= tree["value"] else tree["right"]
    return predict(branch, sample)

def evaluate(data, test_ratio=0.3):
    shuffle(data)
    split_point = int(len(data) * (1 - test_ratio))
    train_data = data[:split_point]
    test_data = data[split_point:]
    tree = build_tree(train_data)
    correct = 0
    for row in test_data:
        if predict(tree, row) == row["risiko"]:
            correct += 1
    print(f"📊 Akurasi pada data uji: {correct/len(test_data):.2f}")

def print_tree(tree, spacing=""):
    if isinstance(tree, str):
        print(spacing + "=>", tree.upper())
        return
    print(spacing + f"[{tree['feature']} <= {tree['value']}]")
    print(spacing + '--> True:')
    print_tree(tree['left'], spacing + "  ")
    print(spacing + '--> False:')
    print_tree(tree['right'], spacing + "  ")

import csv

def load_data_from_csv(filepath):
    data = []
    with open(filepath, "r") as file:
        reader = csv.DictReader(file)
        for row in reader:
            data.append({
                "durasi_mens": int(row["durasi_mens"]),
                "konsumsi": int(row["konsumsi"]),
                "lemas": int(row["lemas"]),
                "berat_badan_turun": int(row["berat_badan_turun"]),
                "usia": int(row["usia"]),
                "riwayat_keluarga": int(row["riwayat_keluarga"]),
                "sleep_kurang": int(row["sleep_kurang"]),
                "risiko": row["risiko"].strip()
            })
    return data

# STEP 4: Prediksi Manual dengan Slider & Dropdown
import ipywidgets as widgets
from IPython.display import display

# Slider untuk durasi menstruasi
durasi_mens = widgets.IntSlider(
    value=5, min=1, max=20, step=1,
    description='Durasi Mens (hari)'
)

# Dropdown konsumsi daging/zat besi
konsumsi = widgets.Dropdown(
    options=[
        ('Sering (2)', 2),
        ('Kadang (1)', 1),
        ('Jarang (0)', 0)
    ],
    description='Konsumsi Zat Besi'
)

# Dropdown rasa lemas
lemas = widgets.Dropdown(
    options=[
        ('Sering lemas (2)', 2),
        ('Kadang lemas (1)', 1),
        ('Tidak lemas (0)', 0)
    ],
    description='Keluhan Lemas'
)

# Dropdown berat badan turun
turun_bb = widgets.Dropdown(
    options=[
        ('Sering turun BB (2)', 2),
        ('Kadang turun BB (1)', 1),
        ('Tidak turun BB (0)', 0)
    ],
    description='Penurunan BB'
)

# Slider usia
usia = widgets.IntSlider(
    value=25, min=10, max=60, step=1,
    description='Usia (tahun)'
)

# Dropdown riwayat keluarga
riwayat = widgets.Dropdown(
    options=[
        ('Ada riwayat (1)', 1),
        ('Tidak ada (0)', 0)
    ],
    description='Riwayat Keluarga'
)

# Dropdown tidur kurang
sleep_kurang = widgets.Dropdown(
    options=[
        ('Sering kurang tidur (2)', 2),
        ('Kadang kurang tidur (1)', 1),
        ('Cukup tidur (0)', 0)
    ],
    description='Kualitas Tidur'
)

print("📥 Silakan isi data gejala & kondisi berikut:")
display(durasi_mens, konsumsi, lemas, turun_bb, usia, riwayat, sleep_kurang)

# STEP 5: Prediksi Berdasarkan Input Form Interaktif

def predict(node, row):
    """
    Fungsi rekursif untuk memprediksi hasil dari decision tree.
    """
    # Jika node adalah hasil akhir (daun pohon)
    if not isinstance(node, dict):
        return node

    attr = node.get("feature")  # Mengakses atribut 'feature' dari node (bukan 'attribute')
    value = node.get("value")

    if attr is None or value is None:
        return node  # Jika struktur node tidak lengkap, kembalikan node apa adanya

    # Lanjutkan ke node kiri atau kanan berdasarkan nilai input pengguna
    if row[attr] < value:
        return predict(node["left"], row)
    else:
        return predict(node["right"], row)

# Ambil nilai dari input form interaktif
sample = {
    "durasi": durasi_mens.value,  # Ganti agar sesuai dengan struktur tree
    "konsumsi": konsumsi.value,
    "lemas": lemas.value,
    "berat_badan_turun": turun_bb.value,
    "usia": usia.value,
    "riwayat_keluarga": riwayat.value,
    "sleep_kurang": sleep_kurang.value
}

# Jalankan prediksi
hasil = predict(tree, sample)

# Tampilkan hasil prediksi
print("\n=== HASIL PREDIKSI RISIKO ANEMIA ===")

# Jika hasil berupa string (hasil akhir), tampilkan
if isinstance(hasil, str):
    print(f"📊 Risiko: {hasil.upper()}")

    if hasil == "tinggi":
        print("🚨 Risiko tinggi! Segera periksa ke dokter.")
    elif hasil == "sedang":
        print("⚠️ Risiko sedang. Perhatikan pola makan & istirahat.")
    elif hasil == "rendah":
        print("✅ Risiko rendah. Pertahankan gaya hidup sehat.")
    else:
        print("❓ Risiko tidak dikenali.")
else:
    # Jika hasil bukan string, berarti belum sampai ke daun pohon
    print("⚠️ Prediksi belum selesai. Ini isi node saat ini:")
    import pprint
    pprint.pprint(hasil)